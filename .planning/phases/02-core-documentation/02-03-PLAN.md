---
phase: 02-core-documentation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - qase-vitest/README.md
  - qase-vitest/docs/usage.md
  - qase-cucumberjs/README.md
  - qase-cucumberjs/docs/usage.md
autonomous: true

must_haves:
  truths:
    - "User can install Vitest reporter with single npm command found in README"
    - "User can copy Vitest minimal working example from README and get first test result"
    - "User can find complete API reference for all qase methods in Vitest usage.md"
    - "User can install CucumberJS reporter with single npm command found in README"
    - "User can copy CucumberJS minimal working example from README and get first test result"
    - "User can find complete API reference for Gherkin tag-based integration in CucumberJS usage.md"
  artifacts:
    - path: "qase-vitest/README.md"
      provides: "Vitest reporter README with installation, quick start, config reference"
      contains: "npm install --save-dev vitest-qase-reporter"
    - path: "qase-vitest/docs/usage.md"
      provides: "Vitest complete API reference and integration guide"
      contains: "qase.fields"
    - path: "qase-cucumberjs/README.md"
      provides: "CucumberJS reporter README with installation, quick start, config reference"
      contains: "npm install --save-dev cucumberjs-qase-reporter"
    - path: "qase-cucumberjs/docs/usage.md"
      provides: "CucumberJS integration guide with Gherkin tag patterns"
      contains: "QaseID"
  key_links:
    - from: "qase-vitest/README.md"
      to: "qase-vitest/docs/usage.md"
      via: "Documentation links table"
      pattern: "docs/usage.md"
    - from: "qase-cucumberjs/README.md"
      to: "qase-cucumberjs/docs/usage.md"
      via: "Documentation links table"
      pattern: "docs/usage.md"
---

<objective>
Apply master documentation templates to Vitest and CucumberJS reporters, creating complete README.md and docs/usage.md for both frameworks.

Purpose: Vitest is Jest-compatible (wrapper function pattern with ESM), while CucumberJS is unique (Gherkin tag-based, no programmatic qase import in tests). This plan covers both modern ESM and BDD-specific patterns.
Output: 4 files (README.md + usage.md for each framework), all placeholders replaced, validated.
</objective>

<execution_context>
@/Users/gda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/templates/README-TEMPLATE.md
@.planning/templates/usage-TEMPLATE.md
@.planning/templates/PLACEHOLDER-REFERENCE.md
@.planning/docs/FRAMEWORK-VARIATIONS.md
@.planning/docs/CODE-STYLE-GUIDE.md
@qase-vitest/README.md
@qase-vitest/docs/usage.md
@qase-cucumberjs/README.md
@qase-cucumberjs/docs/usage.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apply templates to Vitest reporter (README.md + usage.md)</name>
  <files>qase-vitest/README.md, qase-vitest/docs/usage.md</files>
  <action>
Apply master templates to create complete Vitest documentation.

**README.md:**
1. Start from README-TEMPLATE.md structure
2. Read EXISTING qase-vitest/README.md (279 lines) to preserve Vitest-specific content (e.g., vitest.config.ts reporter configuration, compatibility with Jest API)
3. Replace all placeholders:
   - {{FRAMEWORK_NAME}} = Vitest
   - {{PACKAGE_NAME}} = vitest-qase-reporter
   - {{FRAMEWORK_VERSION}} = 0.25.0
   - {{CONFIG_LOCATION}} = vitest.config.ts
   - {{RUN_COMMAND}} = npx vitest run
   - {{QUICK_START_TEST_EXAMPLE}} = ESM pattern: `import { qase } from 'vitest-qase-reporter'; import { test, expect } from 'vitest'; test(qase(1, 'Test name'), () => { expect(true).toBe(true); });`
   - {{LINK_TESTS_EXAMPLE}} = Single and multiple IDs with test() syntax (Jest-like)
   - {{METADATA_EXAMPLE}} = qase.fields(), qase.suite(), qase.title()
   - {{IGNORE_EXAMPLE}} = qase.ignore()
   - {{STATUS_TABLE}} = Pass/Fail/Skip status mapping for Vitest
   - {{RUNNING_TESTS_EXAMPLES}} = npx vitest run, npx vitest run --reporter, watch mode note
4. Include vitest.config.ts reporter configuration (from existing README)
5. Highlight Vitest's Jest-compatible API but ESM-first nature
6. Follow CODE-STYLE-GUIDE.md: ESM imports (`import { qase } from ...`), TypeScript examples preferred, 2-space indent

**usage.md:**
1. Start from usage-TEMPLATE.md structure
2. Read EXISTING qase-vitest/docs/usage.md (286 lines) to preserve existing patterns
3. Replace all placeholders with Vitest-specific examples:
   - QaseID uses `test(qase(id, 'name'), () => {})` wrapper pattern (same as Jest)
   - Import: `import { qase } from 'vitest-qase-reporter';`
   - Steps use async pattern: `await qase.step('name', async () => {})`
   - Attachments: `qase.attach()` patterns
   - Parameters show Vitest test.each and describe.each
   - Troubleshooting includes Vitest-specific errors (ESM module resolution, vitest.config.ts vs vite.config.ts, watch mode vs run mode reporting)
4. Integration Patterns: Vitest workspace support, in-source testing, concurrent tests, snapshot testing with Qase, vi.mock with reporting
5. Common Use Cases / Recipes: 5-10 examples (e.g., "Report with workspace projects", "Run in CI with coverage", "Use concurrent tests", "Migrate from Jest reporter")
6. Validate all internal links

**Validation:** Run validate-placeholders.js - must exit 0.
  </action>
  <verify>
node .planning/tools/validate-placeholders.js qase-vitest/README.md && node .planning/tools/validate-placeholders.js qase-vitest/docs/usage.md && echo "Vitest validation passed"
  </verify>
  <done>
Vitest README.md has: installation, ESM quick start, vitest.config.ts setup, configuration reference, requirements, documentation links. Vitest usage.md has: QaseID with test() wrapper, all qase.* methods with ESM imports, async step examples, Vitest troubleshooting (5+ errors), integration patterns (3+ patterns), common use cases (5+ recipes). No unreplaced placeholders.
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply templates to CucumberJS reporter (README.md + usage.md)</name>
  <files>qase-cucumberjs/README.md, qase-cucumberjs/docs/usage.md</files>
  <action>
Apply master templates to create complete CucumberJS documentation. CucumberJS is UNIQUE among the 9 frameworks: it uses Gherkin tags (@QaseID=N) instead of programmatic qase() wrapper functions. The template must be adapted significantly.

**README.md:**
1. Start from README-TEMPLATE.md structure
2. Read EXISTING qase-cucumberjs/README.md (142 lines) to preserve CucumberJS-specific content (e.g., cucumber.js profile configuration, Gherkin tag syntax)
3. Replace all placeholders:
   - {{FRAMEWORK_NAME}} = CucumberJS
   - {{PACKAGE_NAME}} = cucumberjs-qase-reporter
   - {{FRAMEWORK_VERSION}} = 8.0.0
   - {{CONFIG_LOCATION}} = cucumber.js (profile file)
   - {{RUN_COMMAND}} = npx cucumber-js
   - {{QUICK_START_TEST_EXAMPLE}} = Gherkin with tag: `@QaseID=1\nFeature: Login\n  Scenario: Valid login\n    Given user has valid credentials\n    When user logs in\n    Then user sees dashboard`
   - {{LINK_TESTS_EXAMPLE}} = @QaseID=1 single, @QaseID=1,2,3 multiple IDs
   - {{METADATA_EXAMPLE}} = @QaseTitle, @QaseFields tags, and Before hook with qase.fields() for programmatic use
   - {{IGNORE_EXAMPLE}} = @QaseIgnore tag
   - {{STATUS_TABLE}} = Passed/Failed/Pending/Skipped/Undefined mapping for Cucumber
   - {{RUNNING_TESTS_EXAMPLES}} = npx cucumber-js, npx cucumber-js --tags, profile configuration
4. CRITICAL ADAPTATION: CucumberJS does NOT import qase in test files. Test case linking is via Gherkin tags. Make this distinction very clear in README.
5. Show cucumber.js profile configuration for reporter registration
6. Follow CODE-STYLE-GUIDE.md: use Gherkin syntax for feature file examples, JavaScript for step definitions and hooks

**usage.md:**
1. Start from usage-TEMPLATE.md structure but ADAPT SIGNIFICANTLY for Gherkin/BDD:
   - "Adding QaseID" section shows @QaseID tag, not qase() wrapper
   - "Adding Title" shows @QaseTitle tag
   - "Adding Fields" shows Before hook pattern with qase.fields() (programmatic, in support files)
   - "Adding Suite" shows Feature/Scenario Outline structure as natural suites
   - "Ignoring Tests" shows @QaseIgnore tag
   - "Steps" section is unique: Cucumber has native Given/When/Then steps that map to Qase steps automatically
   - "Attachments" shows Before/After hooks with qase.attach() in support files
   - "Parameters" shows Scenario Outline with Examples table
2. Read EXISTING qase-cucumberjs/docs/usage.md (248 lines) to preserve existing patterns
3. Troubleshooting: tag parsing errors, step definition not found, World object issues, parallel feature execution
4. Integration Patterns: Step definition organization, World objects, Before/After hooks with Qase, Scenario Outline patterns, tag expressions for filtering
5. Common Use Cases / Recipes: 5-10 examples (e.g., "Tag scenarios for specific Qase projects", "Attach screenshots in After hook", "Use Scenario Outline for parameterized testing", "Filter by @QaseID tags")
6. Validate all internal links

**Validation:** Run validate-placeholders.js - must exit 0.
  </action>
  <verify>
node .planning/tools/validate-placeholders.js qase-cucumberjs/README.md && node .planning/tools/validate-placeholders.js qase-cucumberjs/docs/usage.md && echo "CucumberJS validation passed"
  </verify>
  <done>
CucumberJS README.md has: installation, Gherkin quick start with @QaseID tag, cucumber.js profile setup, configuration reference, requirements, documentation links. CucumberJS usage.md has: tag-based QaseID (@QaseID=N), native Given/When/Then step mapping, Before/After hook patterns for metadata, CucumberJS troubleshooting (5+ errors), integration patterns (3+ BDD patterns), common use cases (5+ recipes). Template adapted for Gherkin/BDD paradigm. No unreplaced placeholders.
  </done>
</task>

</tasks>

<verification>
1. `node .planning/tools/validate-placeholders.js qase-vitest/` exits 0
2. `node .planning/tools/validate-placeholders.js qase-cucumberjs/` exits 0
3. Both READMEs follow template section order (adapted where necessary)
4. Vitest uses ESM imports: `import { qase } from 'vitest-qase-reporter'`
5. CucumberJS shows Gherkin tag syntax: `@QaseID=1` (NOT wrapper function)
6. CucumberJS usage.md is adapted for BDD paradigm (tags, hooks, Given/When/Then)
7. Both usage.md files have Troubleshooting, Integration Patterns, and Common Use Cases sections
</verification>

<success_criteria>
- Vitest and CucumberJS each have complete README.md following template structure
- Vitest and CucumberJS each have complete usage.md with all API methods documented
- CucumberJS documentation correctly uses Gherkin tag-based patterns instead of wrapper functions
- No unreplaced placeholders in any file
- Framework-specific paradigms correctly represented
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-documentation/02-03-SUMMARY.md`
</output>
